(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
const Matrix = require('./matrix');
const Vector = require('./vector');

let canvas = document.getElementById('cubecanvas');
let context = canvas.getContext('2d');

let rotationMatrix = null;
let rotationDegrees = 0;
const orbitRadius = 10;

function drawCube(corner, corner2) {
  const centerX = 0.5 * canvas.width;
  const centerY = 0.5 * canvas.height;
  const scale = 1.4 * min(centerX, centerY);
  const v1 = corner1;
  const v2 = corner2;
  const v3 = new Vector(v1.x, v2.y, v1.z);
  const v4 = new Vector(v2.x, v2.y, v1.z);
  const v5 = new Vector(v2.x, v1.y, v1.z);
  const v6 = new Vector(v1.x, v2.y, v1.z);
  const v7 = new Vector(v2.x, v2.y, v1.z);
  const v8 = new Vector(v2.x, v1.y, v1.z);
  const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];
  context.fillStyle = 'rgba(255,255,255,0.5)';
  for (let i = 0; i < vertices.length; ++i) {
    const vertex = vertices[i];
    let transformed = rotationMatrix.vectorMultiply(vertex);
    transformed.z += orbitRadius;
    if (transformed.z < 0.0000001) {
      continue;
    }
    const sx = centerX + scale * transformed.x / transformed.z;
    const sy = centerY + scale * transformed.y / transformed.z;
    context.beginPath();
    context.arc(sx, sy, 10, 0, 2 * Math.PI);
    context.fill();
  }
}

function doFrame() {
  context.fillStyle = 'black';
  context.fillRect(0, 0, canvas.width, canvas.height);
  const rotationAxis = new Vector(1, 0.5, 0);
  const rotationRadians = rotationDegrees * Math.PI / 180;
  rotationMatrix = rotationAxis.rotationMatrix(rotationRadians);
  rotationDegrees += 1;
  drawCube(new Vector(1, 1, 1), new Vector(2, 2, 2));
  setTimeout(doFrame, 30);
}

setTimeout(doFrame, 1);

},{"./matrix":2,"./vector":3}],2:[function(require,module,exports){
// Represents 3x3 matrix. Used for doing 3D calculations.

const Vector = require('./vector');

function Matrix(xx, xy, xz,
		yx, yy, yz,
		zx, zy, zz) {
    this.xx = xx;
    this.xy = xy;
    this.xz = xz;
    this.yx = yx;
    this.yy = yy;
    this.yz = yz;
    this.zx = zx;
    this.zy = zy;
    this.zz = zz;
}

Matrix.prototype.multiplyScalar = function(k) {
    return new Matrix(k * this.xx, k * this.xy, k * this.xz,
		      k * this.yx, k * this.yy, k * this.yz,
		      k * this.zx, k * this.zy, k * this.zz);
};

Matrix.prototype.multiplyScalarInPlace = function(k) {
    this.xx *= k;
    this.xy *= k;
    this.xz *= k;
    this.yx *= k;
    this.yy *= k;
    this.yz *= k;
    this.zx *= k;
    this.zy *= k;
    this.zz *= k;
};

Matrix.prototype.addInPlace = function(other) {
    this.xx += other.xx;
    this.xy += other.xy;
    this.xz += other.xz;
    this.yx += other.yx;
    this.yy += other.yy;
    this.yz += other.yz;
    this.zx += other.zx;
    this.zy += other.zy;
    this.zz += other.zz;
};

Matrix.prototype.absoluteMax = function() {
    return Math.max(this.xx, this.xy, this.xz,
		    this.yx, this.yy, this.yz,
		    this.zx, this.zy, this.zz,
		    -this.xx, -this.xy, -this.xz,
		    -this.yx, -this.yy, -this.yz,
		    -this.zx, -this.zy, -this.zz);
};

Matrix.add = function(a, b) {
    return new Matrix(a.xx + b.xx, a.xy + b.xy, a.xz + b.xz,
		      a.yx + b.yx, a.yy + b.yy, a.yz + b.yz,
		      a.zx + b.zx, a.zy + b.zy, a.zz + b.zz);
};

Matrix.subtract = function(a, b) {
    return new Matrix(a.xx - b.xx, a.xy - b.xy, a.xz - b.xz,
		      a.yx - b.yx, a.yy - b.yy, a.yz - b.yz,
		      a.zx - b.zx, a.zy - b.zy, a.zz - b.zz);
};

Matrix.maxDifference = function(a, b) {
    difference = Matrix.subtract(a, b);
    return difference.absoluteMax();
};

Matrix.identity = function(k) {
    if (k === undefined) {
	k = 1;
    }
    return new Matrix(k, 0, 0,
		      0, k, 0,
		      0, 0, k);
};

Matrix.prototype.vectorMultiply = function(v) {
    var r = new Vector(v.x * this.xx + v.y * this.xy + v.z * this.xz,
		       v.x * this.yx + v.y * this.yy + v.z * this.yz,
		       v.x * this.zx + v.y * this.zy + v.z * this.zz);
    return r;
};

module.exports = Matrix;

},{"./vector":3}],3:[function(require,module,exports){
// 3D vector

const Matrix = require('./matrix');

function Vector(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
}

Vector.prototype.print = function() {
    return "X: "+this.x+" Y: "+this.y+" Z: "+this.z;
}

Vector.prototype.copyFrom = function(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
};

Vector.prototype.isEqual = function(v) {
    return (this.x == v.x) &&
        (this.y == v.y) &&
        (this.z == v.z);
}

Vector.prototype.tensorProduct = function() {
    return new Matrix(this.x * this.x, this.x * this.y, this.x * this.z,
		      this.y * this.x, this.y * this.y, this.y * this.z,
		      this.z * this.x, this.z * this.y, this.z * this.z);
};

Vector.prototype.crossProductMatrix = function() {
    return new Matrix(0, -this.z, this.y,
		      this.z, 0, -this.x,
		      -this.y, this.x, 0);
};

Vector.crossProduct = function(a, b) {
    return new Vector(a.y * b.z - a.z * b.y,
		      a.z * b.x - a.x * b.z,
		      a.x * b.y - a.y * b.x);
};

Vector.dotProduct = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
};

Vector.prototype.multiplyScalar = function(k) {
    return new Vector(k * this.x, k * this.y, k * this.z);
};

Vector.prototype.projectOnto = function(v) {
    var len = v.squaredLength();
    if (len < 0.0000001) {
	return new Vector(0, 0, 0);
    }
    var mult = Vector.dotProduct(this, v) / len;
    return v.multiplyScalar(mult);
};

// This function ONLY works if v is a unit vector!
Vector.prototype.projectOntoUnitVector = function(v) {
    return v.multiplyScalar(Vector.dotProduct(this, v));
};

// Performs a change of basis defined by a, b, and c. The arguments MUST be
// unit vectors or else the results are undefined!
Vector.prototype.basisProjection = function(a, b, c) {
    return new Vector(Vector.dotProduct(this, a),
		      Vector.dotProduct(this, b),
		      Vector.dotProduct(this, c));
};

// Implements Rodrigues' rotation formula. Yields a 3D rotation matrix that
// rotates some vector around this vector by the given angle.
Vector.prototype.rotationMatrix = function(angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var m = Matrix.identity(cos);
    var crossProductMatrix = this.crossProductMatrix();
    crossProductMatrix.multiplyScalarInPlace(sin);
    m.addInPlace(crossProductMatrix);
    var tensorProduct = this.tensorProduct();
    tensorProduct.multiplyScalarInPlace(1.0 - cos);
    m.addInPlace(tensorProduct);
    return m;
};

// Returns this vector rotated around a given axis by a given angle.
Vector.prototype.rotate = function(axis, angle) {
    var matrix = axis.rotationMatrix(angle);
    return matrix.vectorMultiply(this);
};

Vector.prototype.squaredLength = function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
};

Vector.subtract = function(a, b) {
    return new Vector(a.x - b.x, a.y - b.y, a.z - b.z);
};

Vector.prototype.subtract = function(v) {
    return Vector.subtract(this, v);
};

Vector.prototype.addInPlace = function(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
};

Vector.squaredDistance = function(a, b) {
    return Vector.subtract(a, b).squaredLength();
};

module.exports = Vector;

},{"./matrix":2}]},{},[1]);
